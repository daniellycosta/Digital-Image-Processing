<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Exercícios da 2ª Unidade · DCA0445 - Processamento Digital de Imagens</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Exercícios **7 - 9** encontrados na [página do professor Agostinho Brito](https://agostinhobritojr.github.io/tutorial/pdi/)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Exercícios da 2ª Unidade · DCA0445 - Processamento Digital de Imagens"/><meta property="og:type" content="website"/><meta property="og:url" content="https://daniellycosta.github.io/Digital-Image-Processing/"/><meta property="og:description" content="Exercícios **7 - 9** encontrados na [página do professor Agostinho Brito](https://agostinhobritojr.github.io/tutorial/pdi/)"/><meta property="og:image" content="https://daniellycosta.github.io/Digital-Image-Processing/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://daniellycosta.github.io/Digital-Image-Processing/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/Digital-Image-Processing/"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/Digital-Image-Processing/js/scrollSpy.js"></script><link rel="stylesheet" href="/Digital-Image-Processing/css/main.css"/><script src="/Digital-Image-Processing/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Digital-Image-Processing/"><h2 class="headerTitle">DCA0445 - Processamento Digital de Imagens</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/Digital-Image-Processing/docs/doc1" target="_self">1ª Unidade</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/Digital-Image-Processing/docs/doc2" target="_self">2ª Unidade</a></li><li class="siteNavGroupActive"><a href="/Digital-Image-Processing/docs/doc3" target="_self">3ª Unidade</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>2ª Unidade</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">1ª Unidade</h3><ul class=""><li class="navListItem"><a class="navItem" href="/Digital-Image-Processing/docs/doc1">Exercícios Práticos</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">2ª Unidade</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/Digital-Image-Processing/docs/doc2">Exercícios Práticos 2</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3ª Unidade</h3><ul class=""><li class="navListItem"><a class="navItem" href="/Digital-Image-Processing/docs/doc3">Exercícios Práticos 3</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Exercícios da 2ª Unidade</h1></header><article><div><span><p>Exercícios <strong>7 - 9</strong> encontrados na <a href="https://agostinhobritojr.github.io/tutorial/pdi/">página do professor Agostinho Brito</a></p>
<h2><a class="anchor" aria-hidden="true" id="filtragem-no-domínio-da-frequência"></a><a href="#filtragem-no-domínio-da-frequência" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filtragem no domínio da frequência</h2>
<h2><a class="anchor" aria-hidden="true" id="detecção-de-bordas-com-o-algoritmo-de-canny"></a><a href="#detecção-de-bordas-com-o-algoritmo-de-canny" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Detecção de bordas com o algoritmo de Canny</h2>
<p>No exercício, que pode ser encontrado <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_7">nesse link</a>, foi pedido para que utilize-se o <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/pontilhismo.cpp">código de pontilhismo</a> juntamente com o do <a href="https://agostinhobritojr.github.io/tutorial/pdi/exemplos/canny.cpp">algoritmo de Canny</a> para melhorar a qualidade da imagem pontilhista.</p>
<p>Para isso, primeiramente os dois códigos foram traduzidos pra linguagem python e combinados em um único arquivo. Em seguida gerou-se, com a imagem passada como parâmetro na execução, uma versão pontilhada e uma versão de bordas, que podem ser conferidas nas Figuras 1,2 e 3 abaixo.</p>
<p><center></p>
<figure float="middle" class="image">
  <img src="./assets/biel.png" alt="biel.png">
  <figcaption>Figura 1 - Imagem de entrada</figcaption> 
</figure>
<figure class="image">
  <img src="./assets/point.jpg" alt="points.jpg">
  <figcaption>Figura 2 - Imagem de pontilhada</figcaption>  
</figure>
<figure class="image">
  <img src="./assets/canny.jpg" alt="canny.jpg">
  <figcaption>Figura 3 - Imagem com bordas detectadas</figcaption>  
</figure>
</center>
<p>De posse das duas imagens, a combinação delas foi feita conforme mostrado no código abaixo. Os píxels da figura foram percorridos e em cada um deles foi avaliado o valor de sua borda. Sendo o píxel em questão pertencente a uma borda, ou seja, não possuindo a cor preta (0) é desenhado um círculo com as cor do pixel da imagem original.</p>
<pre><code class="hljs css language-python">image = cv.imread(cv.samples.findFile(path), cv.IMREAD_GRAYSCALE)
rows, columns = image.shape
<span class="hljs-comment">#...</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(columns):
        <span class="hljs-keyword">if</span>(edges[i, j] != <span class="hljs-number">0</span>):
            gray = image[i,j]
            cv.circle(points,
                    (j, i),
                    CANNY_RADIUS,
                    int(gray),
                    <span class="hljs-number">-1</span>,
                    cv.LINE_AA)

</code></pre>
<p>O resultado pode ser conferido na Figura 4 abaixo:</p>
<p><center></p>
<figure class="image">
  <img src="./assets/canny_point.jpg" alt="canny_point.jpg">
  <figcaption>Figura 4 - Imagem final</figcaption>  
</figure>
</center>
<p>O código na íntegra pode ser encontrado <a href="https://github.com/daniellycosta/Digital-Image-Processing/blob/main/canny_point/setup.py">aqui</a></p>
<h2><a class="anchor" aria-hidden="true" id="quantização-vetorial-com-k-means"></a><a href="#quantização-vetorial-com-k-means" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quantização vetorial com K-means</h2>
<p>Nesse exercício, encontrado <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_8">aqui</a>, foi pedido para que a partir do programa fornecido fossem iniciados os centros de forma aleatória, 10 vezes. Além disso, foi pedido pra explicar o motivo das imagens resultantes poderem divergir tanto.</p>
<p>Assim como nos exercícios anteriores, o primeiro passo foi traduzir o código fornecido para python. Já a partir do segundo é que as modificações foram feitas de fato.
As modificações começaram com a troca da flag de definição de centro com o objetivo de inserir a escolha randômica conforme pode ser visto no trecho abaixo.</p>
<pre><code class="hljs css language-pyhton"> ret,<span class="hljs-built_in">label</span>,<span class="hljs-built_in">center</span>=<span class="hljs-built_in">cv</span>.kmeans(samples,n_clusters,None,criteria,n_attempts,<span class="hljs-built_in">cv</span>.KMEANS_RANDOM_CENTERS)
</code></pre>
<p>Em seguida englobou-se o código com um laço, de modo a possibilitar as 10 execuções. Ficando como no trecho abaixo</p>
<pre><code class="hljs css language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
    samples = img.reshape((<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>))
    samples = np.float32(samples)

    criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, <span class="hljs-number">10000</span>, <span class="hljs-number">0.0001</span>)

    ret,label,center=cv.kmeans(samples,n_clusters,<span class="hljs-literal">None</span>,criteria,n_attempts,cv.KMEANS_RANDOM_CENTERS)

    center = np.uint8(center)
    flattened = center[label.flatten()]
    reshaped = flattened.reshape((img.shape))

    cv.imwrite(<span class="hljs-string">f'images/<span class="hljs-subst">{i}</span>.jpg'</span>, reshaped)
</code></pre>
<p>Os resultados utilizando <code>n-attempts=1</code> e <code>n_cluster=8</code> podem ser conferidos no GIF da Figura 5, montado com as 10 imagens resultantes do algoritmo.</p>
<p><center></p>
<figure class="image">
  <img src="./assets/saidas.gif" alt="saidas.gif">
  <figcaption>Figura 5 - GIF com o compilado das 10 imagens geradas pelo algoritmo do K-means</figcaption>  
</figure>
</center>
<p>Como podemos ver as imagens apresentam diferenças perceptíveis entre si, e isso ocorre devido à utilização de centros randômicos no algoritmo kmeans. Com uma quantidade maior de tentativas os resultados tenderiam a ser mais próximos mas utilizando apenas uma tentativa a aleatoriedade se torna mais notável e gera diferentes resultados.</p>
<p>O código na íntegra pode ser encontrado <a href="https://github.com/daniellycosta/Digital-Image-Processing/blob/main/kmeans/setup.py">aqui</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Digital-Image-Processing/docs/doc1"><span class="arrow-prev">← </span><span>Exercícios Práticos</span></a><a class="docs-next button" href="/Digital-Image-Processing/docs/doc3"><span>Exercícios Práticos 3</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#filtragem-no-domínio-da-frequência">Filtragem no domínio da frequência</a></li><li><a href="#detecção-de-bordas-com-o-algoritmo-de-canny">Detecção de bordas com o algoritmo de Canny</a></li><li><a href="#quantização-vetorial-com-k-means">Quantização vetorial com K-means</a></li></ul></nav></div><footer class="nav-footer" id="footer"></footer></div></body></html>